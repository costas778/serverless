https://aws-tc-largeobjects.s3.us-west-2.amazonaws.com/DEV-AWS-MO-Architecting/exercise-1-serverless.html

Task 1. Setup: Creating IAM policies and roles
When you first create an account on AWS, you become a root user, or an account owner. We don’t recommend that you use the account root user for daily operations and tasks. Instead, you should use an IAM user or IAM roles to access specific services and features. IAM policies, users, and roles are offered at no additional charge.

In this task, you create custom IAM policies and roles to grant limited permissions to specific AWS services.

Step 1.1: Creating custom IAM policies
Sign in to the AWS Management Console.

In the search box, enter IAM.

From the results list, choose IAM.

In the navigation pane, choose Policies.

Choose Create policy.

The Create policy page appears. You can create and edit a policy in the visual editor or use JSON. In this exercise, we provide JSON scripts to create policies. In total, you must create four policies.

In the JSON tab, paste the following code:

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "dynamodb:PutItem",
                "dynamodb:DescribeTable"
            ],
            "Resource": "*"
        }
    ]
}
Copy to clipboard
This JSON script grants permissions to put items into the DynamoDB table. The asterisk (*) indicates that the specified actions can apply to all available resources.

Choose Next: Tags and then choose Next: Review.

For the policy name, enter Lambda-Write-DynamoDB.

Choose Create policy.

After you create the Lambda-Write-DynamoDB policy, repeat the previous steps to create the following policies:

A policy for Amazon SNS to get, list, and publish topics that are received by Lambda:

Name: Lambda-SNS-Publish
JSON:
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "sns:Publish",
                "sns:GetTopicAttributes",
                    "sns:ListTopics"
            ],
                "Resource": "*"
        }
    ]
 }
Copy to clipboard
A policy for Lambda to get records from DynamoDB Streams:

Name: Lambda-DynamoDBStreams-Read
JSON:
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "dynamodb:GetShardIterator",
                "dynamodb:DescribeStream",
                "dynamodb:ListStreams",
                "dynamodb:GetRecords"
            ],
            "Resource": "*"
        }
    ]
}
Copy to clipboard
A policy for Lambda to read messages that are placed in Amazon SQS:

Name: Lambda-Read-SQS
JSON:
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "sqs:DeleteMessage",
                "sqs:ReceiveMessage",
                "sqs:GetQueueAttributes",
                "sqs:ChangeMessageVisibility"
            ],
            "Resource": "*"
        }
    ]
}
Copy to clipboard
Step 1.2: Creating IAM roles and attaching policies to the roles
Because AWS follows the principle of least privilege, we recommend that you provide role-based access to only the AWS resources that are required to perform a task. In this step, you create IAM roles and attach policies to the roles.

In the navigation pane of the IAM dashboard, choose Roles.

Choose Create role and in the Select trusted entity page, configure the following settings:
Trusted entity type: AWS service
Common use cases: Lambda
Choose Next.

On the Add permissions page, select Lambda-Write-DynamoDB and Lambda-Read-SQS.

Choose Next

For Role name, enter Lambda-SQS-DynamoDB.

Choose Create role.

Follow the previous steps to create two more IAM roles:

An IAM role for AWS Lambda: This role grants permissions to obtain records from the DynamoDB streams and send the records to Amazon SNS. Use the following information to create the role.
IAM role name: Lambda-DynamoDBStreams-SNS
Trusted entity type: AWS service
Common use cases: Lambda
Attach policies: Lambda-SNS-Publish and Lambda-DynamoDBStreams-Read
An IAM role for Amazon API Gateway: This role grants permissions to send data to the SQS queue and push logs to Amazon CloudWatch for troubleshooting. Use the following information to create the role.
IAM role name: APIGateway-SQS
Trusted entity type: AWS service
Common use cases: API Gateway
Attach policies: AmazonAPIGatewayPushToCloudWatchLogs
Task 2: Creating a DynamoDB table
In this task, you create a DynamoDB table that ingests data that’s passed on through API Gateway.

In the search box of the AWS Management Console, enter DynamoDB.

From the list, choose the DynamoDB service.

On the Get started card, choose Create table and configure the following settings:
Table: orders
Partition key: orderID
Data type: Keep String
Keep the remaining settings at their default values, and choose Create table.

Task 3: Creating an SQS queue
In this task, you create an SQS queue. In the architecture for this exercise, the Amazon SQS receives data records from API Gateway, stores them, and then sends them to a database.

In the AWS Management Console search box, enter SQS and from the list, choose Simple Queue Service.

On the Get started card, choose Create queue.

The Create queue page appears.

Configure the following settings:
Name: POC-Queue
Access Policy: Basic
Define who can send messages to the queue:
Select Only the specified AWS accounts, IAM users and roles
In the box for this option, paste the Amazon Resource Name (ARN) for the APIGateway-SQS IAM role
Note: For example, your IAM role might look similar to the following: arn:aws:iam::<account ID>:role/APIGateway-SQS.
Define who can receive messages from the queue:
Select Only the specified AWS accounts, IAM users and roles.
In the box for this option, paste the ARN for the Lambda-SQS-DynamoDB IAM role.
Note: For example, your IAM role might look similar to the following: arn:aws:iam::<account_ID>:role/Lambda-SQS-DynamoDB
Choose Create queue.

Task 4: Creating a Lambda function and setting up triggers
In this task, you create a Lambda function that reads messages from the SQS queue and writes an order record to the DynamoDB table.

Step 4.1: Creating a Lambda function for the Lambda-SQS-DynamoDB role
In the AWS Management Console search box, enter Lambda and from the list, choose Lambda.

Choose Create function and configure the following settings:
Function option: Author from scratch
Function name: POC-Lambda-1
Runtime: Python 3.9
Change default execution role: Use an existing role
Existing role: Lambda-SQS-DynamoDB
Choose Create function.

Step 4.2: Setting up Amazon SQS as a trigger to invoke the function
If needed, expand the Function overview section.

Choose Add trigger.

For Trigger configuration, enter SQS and choose the service in the list.

For SQS queue, choose POC-Queue.

Add the trigger by choosing Add.

Step 4.3: Adding and deploying the function code
On the POC-Lambda-1 page, in the Code tab, replace the default Lambda function code with the following code:

import boto3, uuid

client = boto3.resource('dynamodb')
table = client.Table("orders")

def lambda_handler(event, context):
    for record in event['Records']:
        print("test")
        payload = record["body"]
        print(str(payload))
        table.put_item(Item= {'orderID': str(uuid.uuid4()),'order':  payload})
Copy to clipboard
Choose Deploy.

The Lambda code passes arguments to a function call. As a result, when a trigger invokes a function, Lambda runs the code that you specify.

When you use Lambda, you are responsible only for your code. Lambda manages the memory, CPU, network, and other resources to run your code.

Step 4.4: Testing the POC-Lambda-1 Lambda function
In the Test tab, create a new event that has the following settings:
Event name: POC-Lambda-Test-1
Template-Optional: SQS
The SQS template appears in the Event JSON field.

Save your changes and choose Test.

After the Lambda function runs successfully, the “Execution result: succeeded” message appears in the notification banner in the Test section. This means that the Lambda function sent a test message “Hello from SQS!” from the SQS template to the DynamoDB table.

Step 4.5: Verifying that the Lambda function adds the test message to a database
In the AWS Management Console search box, enter DynamoDB and from the list, choose DynamoDB.

In the navigation pane, choose Explore items.

Select the orders database. Under Items returned, the orders table returns “Hello from SQS!” from the Lambda function test.

Task 5: Enabling DynamoDB Streams
In this task, you enable DynamoDB Streams. A DynamoDB stream captures information about every modification to data items in the table.

In the DynamoDB console, in the Tables section of the navigation pane, choose Update settings.

In the Tables card, make sure that the orders table is selected.

Choose the Exports and streams tab.

In the DynamoDB stream details section, choose Enable.

For View type, choose New image.

Choose Enable stream.

After the Lambda function reads messages from the SQS queue and writes an order record to the DynamoDB table, DynamoDB Streams captures the primary key attributes from the record.

Task 6: Creating an SNS topic and setting up subscriptions
In this task, you create an SNS topic and set up subscriptions. Amazon SNS coordinates and manages delivering or sending messages to subscriber endpoints or clients.

Step 6.1: Creating a topic in the notification service
In the AWS Management Console, search for SNS and choose Simple Notification Service.

On the Create topic card, enter POC-Topic and choose Next step.

In the Details section, keep the Standard topic type selected and choose Create topic.

On the POC-Topic page, copy the ARN of the topic that you just created and save it for your reference.

You will need the ARN for the SNS topic later in this exercise.

Step 6.2: Subscribing to email notifications
On the Subscriptions tab, choose Create subscription.

For Topic ARN, make sure that the box contains the ARN for POC-Topic.

To receive notifications, for Protocol, choose Email.

For Endpoint, enter your email address.

Choose Create subscription.

The confirmation message is sent to the email address that you specified.

After you receive the confirmation email message, confirm the subscription. If you don’t receive an email message within a few minutes, check the spam folder.

Task 7: Creating an AWS Lambda function to publish a message to the SNS topic
In this task, you create a Lambda function for the Lambda-DynamoDBStreams-SNS role. The second Lambda function uses DynamoDB Streams as a trigger to pass the record of a new entry to Amazon SNS.

Step 7.1: Creating a POC-Lambda-2 function
In the AWS Management Console, search for and open AWS Lambda.

Create a new Lambda function by choosing Create function, and configure the following settings:
Function option: Author from scratch
Function name: POC-Lambda-2
Runtime: Python 3.9
Change default execution role: Use an existing role
Existing role: Lambda-DynamoDBStreams-SNS
This role grants permissions to get records from DynamoDB Streams and send them to Amazon SNS.

Choose Create function.

Step 7.2: Setting up DynamoDB as a trigger to invoke a Lambda function
In the Function overview section, choose Add trigger and configure the following settings:
Trigger configuration: Enter DynamoDB and from the list, choose DynamoDB.
DynamoDB table: orders
Keep the remaining default settings and choose Add.

In the Configuration tab, make sure that you are in the Triggers section and that the DynamoDB state is “Enabled.”

Step 7.3: Configuring the second Lambda function
Choose the Code tab and replace the Lambda function code with the following code:

import boto3, json

client = boto3.client('sns')

def lambda_handler(event, context):

    for record in event["Records"]:

        if record['eventName'] == 'INSERT':
            new_record = record['dynamodb']['NewImage']    
            response = client.publish(
                TargetArn='<Enter Amazon SNS ARN for the POC-Topic>',
                Message=json.dumps({'default': json.dumps(new_record)}),
                MessageStructure='json'
            )
Copy to clipboard
Note: In the function code, replace the TargetArn value with the ARN for the Amazon SNS POC-Topic. Make sure that you remove the placeholder angle brackets (<>).
Note
The exercises in this course will have an associated charge in your AWS account. In this exercise, you will create the following resources:

AWS Identity and Access Management (IAM) policy and user (policies and users are AWS account features, offered at no additional charge)
Amazon DynamoDB table
AWS Lambda functions
Amazon Simple Queue Service (Amazon SQS) queue
Amazon Simple Notification Service (Amazon SNS) topic
Amazon API Gateway
Amazon CloudWatch Logs

The final task in this exercise includes instructions to delete all the resources that you create.

Familiarize yourself with DynamoDB pricing, Amazon SQS pricing, Amazon SNS pricing, Lambda pricing, API Gateway pricing, CloudWatch Logs pricing, and the AWS Free Tier.

Exercise 1. Architecting Solutions: Building a Proof of Concept for a Serverless Solution
This exercise provides you with instructions for how to build a proof of concept for a serverless solution in the AWS Cloud.

Suppose you have a customer that needs a serverless web backend hosted on AWS. The customer sells cleaning supplies and often sees spikes in demand for their website, which means that they need an architecture that can easily scale in and out as demand changes. The customer also wants to ensure that the application has decoupled application components.

The following architectural diagram shows the flow for the serverless solution that you will build.

Architecture diagram for exercise 1
Architecture diagram for exercise 1
In this architecture, you will use a REST API to place a database entry in the Amazon SQS queue. Amazon SQS will then invoke the first Lambda function, which inserts the entry into a DynamoDB table. After that, DynamoDB Streams will capture a record of the new entry in a database and invoke a second Lambda function. The function will pass the database entry to Amazon SNS. After Amazon SNS processes the new record, it will send you a notification through a specified email address.

In this exercise, you will learn how to do the following:

Create IAM policies and roles to follow best practices of working in the AWS Cloud.
Create a DynamoDB table to store data.
Create an Amazon SQS queue to receive, store, and send messages between software components.
Create Lambda functions and set up triggers to invoke actions in different AWS services.
Enable DynamoDB Streams to capture modifications in the database table.
Configure Amazon SNS to receive email or text notifications.
Create a REST API to insert data into a database.
Notes:

To complete the instructions in this exercise, choose the US East (N. Virginia) us-east-1 Region in the navigation pane of the AWS Management Console.

The instructions might prompt you to enter your account ID. Your account ID is a 12-digit account number that appears under your account alias in the top-right corner of the AWS Management Console. When you enter your account number (ID), make sure that you remove hyphens (-).



///////////////////
terraform plan
var.notification_email
  Email address for SNS notifications

  Enter a value: yes


Terraform used the selected providers to generate the following execution plan.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # module.api_gateway.aws_api_gateway_deployment.poc_deployment will be created
  + resource "aws_api_gateway_deployment" "poc_deployment" {
      + created_date  = (known after apply)
      + execution_arn = (known after apply)
      + id            = (known after apply)
      + invoke_url    = (known after apply)
      + rest_api_id   = (known after apply)
    }

  # module.api_gateway.aws_api_gateway_integration.sqs_integration will be created
  + resource "aws_api_gateway_integration" "sqs_integration" {
      + cache_namespace         = (known after apply)
      + connection_type         = "INTERNET"
      + credentials             = (known after apply)
      + http_method             = "POST"
      + id                      = (known after apply)
      + integration_http_method = "POST"
      + passthrough_behavior    = (known after apply)
      + request_parameters      = {
          + "integration.request.header.Content-Type" = "'application/x-www-form-urlencoded'"
        }
      + request_templates       = {
          + "application/json" = "Action=SendMessage&MessageBody=$input.body"
        }
      + resource_id             = (known after apply)
      + rest_api_id             = (known after apply)
      + timeout_milliseconds    = 29000
      + type                    = "AWS"
      + uri                     = "arn:aws:apigateway:us-east-1:sqs:path/654654383633/poc-queue"
    }

  # module.api_gateway.aws_api_gateway_integration_response.integration_response will be created
  + resource "aws_api_gateway_integration_response" "integration_response" {
      + http_method = "POST"
      + id          = (known after apply)
      + resource_id = (known after apply)
      + rest_api_id = (known after apply)
      + status_code = "200"
    }

  # module.api_gateway.aws_api_gateway_method.poc_method will be created
  + resource "aws_api_gateway_method" "poc_method" {
      + api_key_required = false
      + authorization    = "NONE"
      + http_method      = "POST"
      + id               = (known after apply)
      + resource_id      = (known after apply)
      + rest_api_id      = (known after apply)
    }

  # module.api_gateway.aws_api_gateway_method_response.response_200 will be created
  + resource "aws_api_gateway_method_response" "response_200" {
      + http_method     = "POST"
      + id              = (known after apply)
      + resource_id     = (known after apply)
      + response_models = {
          + "application/json" = "Empty"
        }
      + rest_api_id     = (known after apply)
      + status_code     = "200"
    }

  # module.api_gateway.aws_api_gateway_resource.poc_resource will be created
  + resource "aws_api_gateway_resource" "poc_resource" {
      + id          = (known after apply)
      + parent_id   = (known after apply)
      + path        = (known after apply)
      + path_part   = "message"
      + rest_api_id = (known after apply)
    }

  # module.api_gateway.aws_api_gateway_rest_api.poc_api will be created
  + resource "aws_api_gateway_rest_api" "poc_api" {
      + api_key_source               = (known after apply)
      + arn                          = (known after apply)
      + binary_media_types           = (known after apply)
      + created_date                 = (known after apply)
      + description                  = "API Gateway for POC serverless solution"
      + disable_execute_api_endpoint = (known after apply)
      + execution_arn                = (known after apply)
      + id                           = (known after apply)
      + minimum_compression_size     = (known after apply)
      + name                         = "poc-api"
      + policy                       = (known after apply)
      + root_resource_id             = (known after apply)
      + tags                         = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + tags_all                     = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }

      + endpoint_configuration (known after apply)
    }

  # module.api_gateway.aws_api_gateway_stage.poc_stage will be created
  + resource "aws_api_gateway_stage" "poc_stage" {
      + arn           = (known after apply)
      + deployment_id = (known after apply)
      + execution_arn = (known after apply)
      + id            = (known after apply)
      + invoke_url    = (known after apply)
      + rest_api_id   = (known after apply)
      + stage_name    = "poc"
      + tags_all      = (known after apply)
      + web_acl_arn   = (known after apply)
    }

  # module.dynamodb.aws_dynamodb_table.poc_table will be created
  + resource "aws_dynamodb_table" "poc_table" {
      + arn              = (known after apply)
      + billing_mode     = "PAY_PER_REQUEST"
      + hash_key         = "customerID"
      + id               = (known after apply)
      + name             = "poc-table"
      + range_key        = "item"
      + read_capacity    = (known after apply)
      + stream_arn       = (known after apply)
      + stream_enabled   = true
      + stream_label     = (known after apply)
      + stream_view_type = "NEW_AND_OLD_IMAGES"
      + tags_all         = (known after apply)
      + write_capacity   = (known after apply)

      + attribute {
          + name = "customerID"
          + type = "S"
        }
      + attribute {
          + name = "item"
          + type = "S"
        }

      + point_in_time_recovery (known after apply)

      + server_side_encryption (known after apply)

      + ttl (known after apply)
    }

  # module.iam.aws_iam_policy.lambda_dynamodbstreams_read will be created
  + resource "aws_iam_policy" "lambda_dynamodbstreams_read" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + description      = "Policy to allow Lambda to read from DynamoDB Streams"
      + id               = (known after apply)
      + name             = "poc-lambda-dynamodbstreams-read"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "dynamodb:GetShardIterator",
                          + "dynamodb:DescribeStream",
                          + "dynamodb:ListStreams",
                          + "dynamodb:GetRecords",
                        ]
                      + Effect   = "Allow"
                      + Resource = "*"
                      + Sid      = "VisualEditor0"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + policy_id        = (known after apply)
      + tags_all         = (known after apply)
    }

  # module.iam.aws_iam_policy.lambda_read_sqs will be created
  + resource "aws_iam_policy" "lambda_read_sqs" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + description      = "Policy to allow Lambda to read from SQS"
      + id               = (known after apply)
      + name             = "poc-lambda-read-sqs"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "sqs:DeleteMessage",
                          + "sqs:ReceiveMessage",
                          + "sqs:GetQueueAttributes",
                          + "sqs:ChangeMessageVisibility",
                        ]
                      + Effect   = "Allow"
                      + Resource = "*"
                      + Sid      = "VisualEditor0"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + policy_id        = (known after apply)
      + tags_all         = (known after apply)
    }

  # module.iam.aws_iam_policy.lambda_sns_publish will be created
  + resource "aws_iam_policy" "lambda_sns_publish" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + description      = "Policy to allow Lambda to interact with SNS"
      + id               = (known after apply)
      + name             = "poc-lambda-sns-publish"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "sns:Publish",
                          + "sns:GetTopicAttributes",
                          + "sns:ListTopics",
                        ]
                      + Effect   = "Allow"
                      + Resource = "*"
                      + Sid      = "VisualEditor0"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + policy_id        = (known after apply)
      + tags_all         = (known after apply)
    }

  # module.iam.aws_iam_policy.lambda_write_dynamodb will be created
  + resource "aws_iam_policy" "lambda_write_dynamodb" {
      + arn              = (known after apply)
      + attachment_count = (known after apply)
      + description      = "Policy to allow Lambda to put items into DynamoDB"
      + id               = (known after apply)
      + name             = "poc-lambda-write-dynamodb"
      + name_prefix      = (known after apply)
      + path             = "/"
      + policy           = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "dynamodb:PutItem",
                          + "dynamodb:DescribeTable",
                        ]
                      + Effect   = "Allow"
                      + Resource = "*"
                      + Sid      = "VisualEditor0"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + policy_id        = (known after apply)
      + tags_all         = (known after apply)
    }

  # module.iam.aws_iam_role.api_gateway_sqs will be created
  + resource "aws_iam_role" "api_gateway_sqs" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "apigateway.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "poc-api-gateway-sqs"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.iam.aws_iam_role.lambda_sqs_dynamodb will be created
  + resource "aws_iam_role" "lambda_sqs_dynamodb" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "lambda.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "poc-lambda-sqs-dynamodb"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.iam.aws_iam_role_policy_attachment.lambda_basic will be created
  + resource "aws_iam_role_policy_attachment" "lambda_basic" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      + role       = "poc-lambda-sqs-dynamodb"
    }

  # module.iam.aws_iam_role_policy_attachment.lambda_sqs_dynamodb_policy1 will be created
  + resource "aws_iam_role_policy_attachment" "lambda_sqs_dynamodb_policy1" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = "poc-lambda-sqs-dynamodb"
    }

  # module.iam.aws_iam_role_policy_attachment.lambda_sqs_dynamodb_policy2 will be created
  + resource "aws_iam_role_policy_attachment" "lambda_sqs_dynamodb_policy2" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = "poc-lambda-sqs-dynamodb"
    }

  # module.lambda.aws_lambda_event_source_mapping.dynamodb_trigger will be created
  + resource "aws_lambda_event_source_mapping" "dynamodb_trigger" {
      + arn                           = (known after apply)
      + batch_size                    = 1
      + enabled                       = true
      + event_source_arn              = (known after apply)
      + function_arn                  = (known after apply)
      + function_name                 = (known after apply)
      + id                            = (known after apply)
      + last_modified                 = (known after apply)
      + last_processing_result        = (known after apply)
      + maximum_record_age_in_seconds = (known after apply)
      + maximum_retry_attempts        = (known after apply)
      + parallelization_factor        = (known after apply)
      + starting_position             = "LATEST"
      + state                         = (known after apply)
      + state_transition_reason       = (known after apply)
      + tags_all                      = (known after apply)
      + uuid                          = (known after apply)

      + amazon_managed_kafka_event_source_config (known after apply)

      + self_managed_kafka_event_source_config (known after apply)
    }

  # module.lambda.aws_lambda_event_source_mapping.sqs_trigger will be created
  + resource "aws_lambda_event_source_mapping" "sqs_trigger" {
      + arn                           = (known after apply)
      + batch_size                    = 1
      + enabled                       = true
      + event_source_arn              = (known after apply)
      + function_arn                  = (known after apply)
      + function_name                 = (known after apply)
      + id                            = (known after apply)
      + last_modified                 = (known after apply)
      + last_processing_result        = (known after apply)
      + maximum_record_age_in_seconds = (known after apply)
      + maximum_retry_attempts        = (known after apply)
      + parallelization_factor        = (known after apply)
      + state                         = (known after apply)
      + state_transition_reason       = (known after apply)
      + tags_all                      = (known after apply)
      + uuid                          = (known after apply)

      + amazon_managed_kafka_event_source_config (known after apply)

      + self_managed_kafka_event_source_config (known after apply)
    }

  # module.lambda.aws_lambda_function.dynamodb_to_sns will be created
  + resource "aws_lambda_function" "dynamodb_to_sns" {
      + architectures                  = (known after apply)
      + arn                            = (known after apply)
      + code_sha256                    = (known after apply)
      + filename                       = "modules/lambda/functions/dynamodb_to_sns.zip"
      + function_name                  = "poc-dynamodb-to-sns"
      + handler                        = "index.handler"
      + id                             = (known after apply)
      + invoke_arn                     = (known after apply)
      + last_modified                  = (known after apply)
      + memory_size                    = 128
      + package_type                   = "Zip"
      + publish                        = false
      + qualified_arn                  = (known after apply)
      + qualified_invoke_arn           = (known after apply)
      + reserved_concurrent_executions = -1
      + role                           = (known after apply)
      + runtime                        = "nodejs14.x"
      + signing_job_arn                = (known after apply)
      + signing_profile_version_arn    = (known after apply)
      + skip_destroy                   = false
      + source_code_hash               = (known after apply)
      + source_code_size               = (known after apply)
      + tags                           = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + tags_all                       = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + timeout                        = 30
      + version                        = (known after apply)

      + environment {
          + variables = (known after apply)
        }

      + ephemeral_storage (known after apply)

      + logging_config (known after apply)

      + tracing_config (known after apply)
    }

  # module.lambda.aws_lambda_function.sqs_to_dynamodb will be created
  + resource "aws_lambda_function" "sqs_to_dynamodb" {
      + architectures                  = (known after apply)
      + arn                            = (known after apply)
      + code_sha256                    = (known after apply)
      + filename                       = "modules/lambda/functions/sqs_to_dynamodb.zip"
      + function_name                  = "poc-sqs-to-dynamodb"
      + handler                        = "index.handler"
      + id                             = (known after apply)
      + invoke_arn                     = (known after apply)
      + last_modified                  = (known after apply)
      + memory_size                    = 128
      + package_type                   = "Zip"
      + publish                        = false
      + qualified_arn                  = (known after apply)
      + qualified_invoke_arn           = (known after apply)
      + reserved_concurrent_executions = -1
      + role                           = (known after apply)
      + runtime                        = "nodejs14.x"
      + signing_job_arn                = (known after apply)
      + signing_profile_version_arn    = (known after apply)
      + skip_destroy                   = false
      + source_code_hash               = (known after apply)
      + source_code_size               = (known after apply)
      + tags                           = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + tags_all                       = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + timeout                        = 30
      + version                        = (known after apply)

      + environment {
          + variables = {
              + "AWS_REGION"     = "us-east-1"
              + "DYNAMODB_TABLE" = "poc-table"
            }
        }

      + ephemeral_storage (known after apply)

      + logging_config (known after apply)

      + tracing_config (known after apply)
    }

  # module.sns.aws_sns_topic.poc_topic will be created
  + resource "aws_sns_topic" "poc_topic" {
      + arn                         = (known after apply)
      + beginning_archive_time      = (known after apply)
      + content_based_deduplication = false
      + fifo_topic                  = false
      + id                          = (known after apply)
      + name                        = "poc-topic"
      + name_prefix                 = (known after apply)
      + owner                       = (known after apply)
      + policy                      = (known after apply)
      + signature_version           = (known after apply)
      + tags_all                    = (known after apply)
      + tracing_config              = (known after apply)
    }

  # module.sns.aws_sns_topic_subscription.email_subscription will be created
  + resource "aws_sns_topic_subscription" "email_subscription" {
      + arn                             = (known after apply)
      + confirmation_timeout_in_minutes = 1
      + confirmation_was_authenticated  = (known after apply)
      + endpoint                        = "yes"
      + endpoint_auto_confirms          = false
      + filter_policy_scope             = (known after apply)
      + id                              = (known after apply)
      + owner_id                        = (known after apply)
      + pending_confirmation            = (known after apply)
      + protocol                        = "email"
      + raw_message_delivery            = false
      + topic_arn                       = (known after apply)
    }

  # module.sqs.aws_sqs_queue.poc_queue will be created
  + resource "aws_sqs_queue" "poc_queue" {
      + arn                               = (known after apply)
      + content_based_deduplication       = false
      + deduplication_scope               = (known after apply)
      + delay_seconds                     = 0
      + fifo_queue                        = false
      + fifo_throughput_limit             = (known after apply)
      + id                                = (known after apply)
      + kms_data_key_reuse_period_seconds = (known after apply)
      + max_message_size                  = 262144
      + message_retention_seconds         = 345600
      + name                              = "poc-queue"
      + name_prefix                       = (known after apply)
      + policy                            = (known after apply)
      + receive_wait_time_seconds         = 0
      + redrive_allow_policy              = (known after apply)
      + redrive_policy                    = (known after apply)
      + sqs_managed_sse_enabled           = (known after apply)
      + tags                              = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + tags_all                          = {
          + "Environment" = "poc"
          + "ManagedBy"   = "terraform"
          + "Project"     = "serverless-poc"
        }
      + url                               = (known after apply)
      + visibility_timeout_seconds        = 30
    }

  # module.sqs.aws_sqs_queue_policy.poc_queue_policy will be created
  + resource "aws_sqs_queue_policy" "poc_queue_policy" {
      + id        = (known after apply)
      + policy    = (known after apply)
      + queue_url = (known after apply)
    }

Plan: 26 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + api_gateway_endpoint = (known after apply)
  + dynamodb_table_name  = "poc-table"
  + sns_topic_arn        = (known after apply)
╷
│ Warning: Value for undeclared variable
│ 
│ The root module does not declare a variable named "email_endpoint" but a value
│ was found in file "terraform.tfvars". If you meant to use this value, add a
│ "variable" block to the configuration.
│ 
│ To silence these warnings, use TF_VAR_... environment variables to provide
│ certain "global" settings to all configurations in your organization. To reduce
│ the verbosity of these warnings, use the -compact-warnings option.
╵

───────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
costas778@DESKTOP-ZBook08:~/environment_serverless1$ 

//////////////////////////////////////////////

Updated plan

costas778@DESKTOP-ZBook08:~/environment_serverless1$ terraform plan
var.notification_email
  Email address for SNS notifications

  Enter a value: costas778@gmail.com

module.iam.aws_iam_policy.lambda_write_dynamodb: Refreshing state... [id=arn:aws:iam::654654383633:policy/poc-lambda-write-dynamodb]
module.iam.aws_iam_policy.lambda_sns_publish: Refreshing state... [id=arn:aws:iam::654654383633:policy/poc-lambda-sns-publish]
module.iam.aws_iam_policy.lambda_dynamodbstreams_read: Refreshing state... [id=arn:aws:iam::654654383633:policy/poc-lambda-dynamodbstreams-read]
module.iam.aws_iam_policy.lambda_read_sqs: Refreshing state... [id=arn:aws:iam::654654383633:policy/poc-lambda-read-sqs]
module.sns.aws_sns_topic.poc_topic: Refreshing state... [id=arn:aws:sns:us-east-1:654654383633:poc-topic]
module.iam.aws_iam_role.lambda_sqs_dynamodb: Refreshing state... [id=poc-lambda-sqs-dynamodb]
module.iam.aws_iam_role.api_gateway_sqs: Refreshing state... [id=poc-api-gateway-sqs]
module.dynamodb.aws_dynamodb_table.poc_table: Refreshing state... [id=poc-table]
module.sns.aws_sns_topic_subscription.email_subscription: Refreshing state... [id=arn:aws:sns:us-east-1:654654383633:poc-topic:778beb1e-3414-4ffa-9883-62c766750bac]
module.iam.aws_iam_role_policy_attachment.lambda_sqs_dynamodb_policy1: Refreshing state... [id=poc-lambda-sqs-dynamodb-20241120064712863600000002]
module.iam.aws_iam_role_policy_attachment.lambda_sqs_dynamodb_policy2: Refreshing state... [id=poc-lambda-sqs-dynamodb-20241120064712865300000003]
module.iam.aws_iam_role_policy_attachment.lambda_basic: Refreshing state... [id=poc-lambda-sqs-dynamodb-20241120064712835900000001]
module.iam.aws_iam_role_policy_attachment.lambda_dynamodbstreams_policy: Refreshing state... [id=poc-lambda-sqs-dynamodb-20241120070958979900000001]
module.sqs.aws_sqs_queue.poc_queue: Refreshing state... [id=https://sqs.us-east-1.amazonaws.com/654654383633/poc-queue]
module.sqs.aws_sqs_queue_policy.poc_queue_policy: Refreshing state... [id=https://sqs.us-east-1.amazonaws.com/654654383633/poc-queue]
module.api_gateway.aws_api_gateway_rest_api.poc_api: Refreshing state... [id=rufxhmnoph]
module.lambda.aws_lambda_function.dynamodb_to_sns: Refreshing state... [id=poc-dynamodb-to-sns]
module.lambda.aws_lambda_function.sqs_to_dynamodb: Refreshing state... [id=poc-sqs-to-dynamodb]
module.api_gateway.aws_api_gateway_resource.poc_resource: Refreshing state... [id=qy0f8f]
module.api_gateway.aws_api_gateway_method.poc_method: Refreshing state... [id=agm-rufxhmnoph-qy0f8f-POST]
module.api_gateway.aws_api_gateway_method_response.response_200: Refreshing state... [id=agmr-rufxhmnoph-qy0f8f-POST-200]
module.api_gateway.aws_api_gateway_integration.sqs_integration: Refreshing state... [id=agi-rufxhmnoph-qy0f8f-POST]
module.lambda.aws_lambda_event_source_mapping.sqs_trigger: Refreshing state... [id=238de1a2-134b-4ac3-b175-734ca6bfea0e]
module.lambda.aws_lambda_event_source_mapping.dynamodb_trigger: Refreshing state... [id=199619f6-bf7b-44db-99dd-588e99eb66af]
module.api_gateway.aws_api_gateway_integration_response.integration_response: Refreshing state... [id=agir-rufxhmnoph-qy0f8f-POST-200]
module.api_gateway.aws_api_gateway_deployment.poc_deployment: Refreshing state... [id=ckex01]
module.api_gateway.aws_api_gateway_stage.poc_stage: Refreshing state... [id=ags-rufxhmnoph-poc]

Terraform used the selected providers to generate the following execution plan.
Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # module.lambda.aws_lambda_function.dynamodb_to_sns will be updated in-place
  ~ resource "aws_lambda_function" "dynamodb_to_sns" {
        id                             = "poc-dynamodb-to-sns"
      ~ runtime                        = "nodejs20.x" -> "python3.11"
        tags                           = {
            "Environment" = "poc"
            "ManagedBy"   = "terraform"
            "Project"     = "serverless-poc"
        }
        # (28 unchanged attributes hidden)

        # (4 unchanged blocks hidden)
    }

  # module.lambda.aws_lambda_function.sqs_to_dynamodb will be updated in-place
  ~ resource "aws_lambda_function" "sqs_to_dynamodb" {
        id                             = "poc-sqs-to-dynamodb"
      ~ runtime                        = "nodejs20.x" -> "python3.11"
        tags                           = {
            "Environment" = "poc"
            "ManagedBy"   = "terraform"
            "Project"     = "serverless-poc"
        }
        # (28 unchanged attributes hidden)

        # (4 unchanged blocks hidden)
    }

Plan: 0 to add, 2 to change, 0 to destroy.
╷
│ Warning: Value for undeclared variable
│ 
│ The root module does not declare a variable named "email_endpoint" but a value
│ was found in file "terraform.tfvars". If you meant to use this value, add a
│ "variable" block to the configuration.
│ 
│ To silence these warnings, use TF_VAR_... environment variables to provide
│ certain "global" settings to all configurations in your organization. To reduce
│ the verbosity of these warnings, use the -compact-warnings option.
╵

───────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
costas778@DESKTOP-ZBook08:~/environment_serverless1$ 


